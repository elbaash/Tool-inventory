<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Tool Inventory Manager</title>
    <meta name="description" content="AI-powered tool inventory with photo identification and voice batch entry">
    
    <!-- React and dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQUkgVG9vbCBJbnZlbnRvcnkgTWFuYWdlciIsInNob3J0X25hbWUiOiJBSSBJbnZlbnRvcnkiLCJ0aGVtZV9jb2xvciI6IiMyNTYzZWIiLCJiYWNrZ3JvdW5kX2Nv[...]">
    
    <!-- Mobile optimizations -->
    <meta name="theme-color" content="#2563eb">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="AI Tool Inventory">
    
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Added missing hooks to the destructuring so useReducer and useCallback are defined
        const { useState, useEffect, useRef, useReducer, useCallback } = React;
        
        // Icons as SVG components
        const SearchIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
            </svg>
        );
        
        const PlusIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M12 5v14M5 12h14"/>
            </svg>
        );
        
        const BoxIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
            </svg>
        );
        
        const SettingsIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6M1 12h6m6 0h6"/>
            </svg>
        );
        
        const CameraIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/>
            </svg>
        );
        
        const MicIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2M12 19v4M8 23h8"/>
            </svg>
        );
        
        const EditIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
        );
        
        const TrashIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
        );
        
        const CheckIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M20 6 9 17l-5-5"/>
            </svg>
        );
        
        const AlertIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10"/><path d="M12 8v4m0 4h.01"/>
            </svg>
        );
        
        const XIcon = () => (
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path d="M18 6 6 18M6 6l12 12"/>
            </svg>
        );

        function InventoryApp() {
            // State management
            const [items, setItems] = useState([]);
            const [searchQuery, setSearchQuery] = useState('');
            const [filteredItems, setFilteredItems] = useState([]);
            const [view, setView] = useState('search'); // search, add, boxes, settings, aiPhoto, aiVoice
            const [isLoading, setIsLoading] = useState(false);
            const [message, setMessage] = useState({ text: '', type: '' });
            const [showSetupGuide, setShowSetupGuide] = useState(true);
            
            // Settings
            const [settings, setSettings] = useState({
                googleSheetsUrl: localStorage.getItem('googleSheetsUrl') || '',
                autoSync: localStorage.getItem('autoSync') === 'true' || false,
                aiEnabled: localStorage.getItem('aiEnabled') === 'true' || false,
                ollamaUrl: localStorage.getItem('ollamaUrl') || 'http://localhost:11434',
                aiServerUrl: localStorage.getItem('aiServerUrl') || 'http://localhost:8000',
            });

            // Add/Edit item state
            const [editingItem, setEditingItem] = useState(null);
            const [formData, setFormData] = useState({
                name: '',
                box: '',
                quantity: '1',
                notes: '',
                photo: null
            });

            // Voice recording
            const [isRecording, setIsRecording] = useState(false);
            const [transcript, setTranscript] = useState('');
            
            // AI Photo
            const [capturedImage, setCapturedImage] = useState(null);
            const [aiIdentification, setAiIdentification] = useState(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);

            // NEW: Enhanced sync features - OPTIMIZED with useReducer
            const syncReducer = (state, action) => {
                switch (action.type) {
                    case 'SET_CONNECTION_STATUS':
                        return { ...state, connectionStatus: action.payload };
                    case 'SET_LAST_SYNC':
                        return {
                            ...state,
                            lastSyncTime: action.payload.time,
                            lastSyncStatus: action.payload.status
                        };
                    case 'ADD_HISTORY':
                        return {
                            ...state,
                            syncHistory: [action.payload, ...state.syncHistory].slice(0, 20)
                        };
                    case 'SET_TEST_RESULTS':
                        return { ...state, testResults: action.payload };
                    case 'TOGGLE_LOGS':
                        return { ...state, showLogs: !state.showLogs };
                    case 'SET_SHOW_LOGS':
                        return { ...state, showLogs: action.payload };
                    case 'SET_SYNC_DIFF':
                        return {
                            ...state,
                            showSyncDiff: action.payload.show,
                            syncDiffData: action.payload.data
                        };
                    case 'CLOSE_SYNC_DIFF':
                        return { ...state, showSyncDiff: false, syncDiffData: null };
                    default:
                        return state;
                }
            };

            const [syncState, dispatchSync] = useReducer(syncReducer, {
                connectionStatus: 'unknown',
                lastSyncTime: null,
                lastSyncStatus: null,
                syncHistory: [],
                testResults: null,
                showLogs: false,
                showSyncDiff: false,
                syncDiffData: null
            });

            // Setup progress persisted to localStorage
            const [setupProgress, setSetupProgress] = useState(() => {
                try {
                    const saved = localStorage.getItem('setupProgress');
                    return saved ? JSON.parse(saved) : {
                        step1: false,
                        step2: false,
                        step3: false,
                        step4: false,
                        step5: false
                    };
                } catch (e) {
                    return { step1: false, step2: false, step3: false, step4: false, step5: false };
                }
            });

            // Update setup progress with persistence
            const updateSetupProgress = (step, value) => {
                const newProgress = { ...setupProgress, [step]: value };
                setSetupProgress(newProgress);
                try {
                    localStorage.setItem('setupProgress', JSON.stringify(newProgress));
                } catch (e) {
                    console.error('Failed to save setup progress:', e);
                }
            };

            // Sync logs stored in localStorage, loaded only when needed
            const [syncLogs, setSyncLogs] = useState([]);

            // Request deduplication
            const syncInProgress = useRef(false);
            const abortControllers = useRef(new Set());

            // ============================================
            // UTILITY FUNCTIONS - Enhanced Error Handling
            // ============================================

            // Log helper function - OPTIMIZED to use localStorage
            const addLog = useCallback((level, message, details = null) => {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    level,
                    message,
                    details
                };

                // Console log with appropriate method
                const logMethod = level === 'error' ? console.error : level === 'warning' ? console.warn : console.log;
                logMethod(`[${level.toUpperCase()}] ${message}`, details || '');

                try {
                    // Store in localStorage, not React state (prevents memory leaks)
                    const logs = JSON.parse(localStorage.getItem('syncLogs') || '[]');
                    logs.unshift(logEntry);
                    const trimmedLogs = logs.slice(0, 100); // Keep last 100
                    localStorage.setItem('syncLogs', JSON.stringify(trimmedLogs));

                    // Only update state if logs modal is open (performance optimization)
                    if (syncState.showLogs) {
                        setSyncLogs(trimmedLogs);
                    }
                } catch (e) {
                    console.error('Failed to save log:', e);
                }
            }, [syncState.showLogs]);

            // Load logs from localStorage when modal opens
            const loadLogs = useCallback(() => {
                try {
                    const logs = JSON.parse(localStorage.getItem('syncLogs') || '[]');
                    setSyncLogs(logs);
                } catch (e) {
                    console.error('Failed to load logs:', e);
                    setSyncLogs([]);
                }
            }, []);

            // URL Validation
            const validateGoogleSheetsUrl = (url) => {
                if (!url || url.trim() === '') {
                    return { valid: false, error: 'URL is empty. Please enter your Google Apps Script URL.' };
                }

                // Must be HTTPS
                if (!url.startsWith('https://')) {
                    return { valid: false, error: 'URL must start with https:// for security.' };
                }

                // Must be Google Apps Script URL
                if (!url.includes('script.google.com/macros/')) {
                    return {
                        valid: false,
                        error: 'This doesn\'t look like a Google Apps Script URL. It should contain "script.google.com/macros/"'
                    };
                }

                // Should end with /exec (deployed) not /dev (test mode)
                if (url.includes('/dev')) {
                    return {
                        valid: false,
                        error: '⚠️ This is a DEVELOPMENT URL. You must deploy the script properly!\n\nGo to Apps Script → Deploy → New deployment → Set as "Web app"'
                    };
                }

                if (!url.endsWith('/exec')) {
                    return {
                        valid: false,
                        error: 'URL should end with /exec. Make sure you copied the complete deployment URL.'
                    };
                }

                return { valid: true };
            };

            // Error Type Detection
            const detectErrorType = (error, response) => {
                // Network error (no response at all)
                if (!response && error.message === 'Failed to fetch') {
                    return {
                        type: 'NETWORK',
                        title: '🌐 Network Error',
                        message: 'Cannot reach Google Sheets',
                        help: '• Check your internet connection\n• Check if firewall is blocking the request\n• Try opening the URL in a new browser tab',
                        severity: 'error'
                    };
                }

                // Timeout
                if (error.message && error.message.includes('timeout')) {
                    return {
                        type: 'TIMEOUT',
                        title: '⏱️ Request Timeout',
                        message: 'Google Sheets took too long to respond',
                        help: '• Your spreadsheet might be very large\n• Try again in a few moments\n• Check your internet speed',
                        severity: 'warning'
                    };
                }

                // CORS error (typical with wrong deployment)
                if (!response || (error.message && error.message.toLowerCase().includes('cors'))) {
                    return {
                        type: 'CORS',
                        title: '🚫 Access Blocked (CORS)',
                        message: 'Deployment configuration issue detected',
                        help: '📋 FIX THIS:\n1. Go to your Google Apps Script\n2. Click "Deploy" → "Manage deployments"\n3. Click the pencil icon (⚙️ Edit)\n4. Set "Who has access" to "An[...]',
                        severity: 'error'
                    };
                }

                // HTTP errors
                if (response) {
                    if (response.status === 401 || response.status === 403) {
                        return {
                            type: 'AUTH',
                            title: '🔐 Authorization Failed',
                            message: `Access denied (HTTP ${response.status})`,
                            help: '• Click your Google Apps Script URL in a browser\n• Make sure you authorize the app\n• Ensure "Execute as: Me" is selected in deployment\n• Try re-deplo[...]',
                            severity: 'error'
                        };
                    }
                    if (response.status === 404) {
                        return {
                            type: 'NOT_FOUND',
                            title: '❓ Script Not Found',
                            message: 'Could not find the Google Apps Script',
                            help: '• Double-check you copied the COMPLETE URL\n• Make sure the script is actually deployed\n• Try deploying again and get a new URL',
                            severity: 'error'
                        };
                    }
                    if (response.status === 500 || response.status === 502) {
                        return {
                            type: 'SERVER',
                            title: '⚙️ Google Script Error',
                            message: 'Error in your Google Apps Script code',
                            help: '• Open Apps Script editor\n• Check "Executions" log for errors\n• Make sure you copied the COMPLETE script code\n• Verify your spreadsheet has the corre[...]',
                            severity: 'error'
                        };
                    }
                }

                return {
                    type: 'UNKNOWN',
                    title: '❌ Sync Failed',
                    message: error.message || 'Unknown error occurred',
                    help: '• Check the logs for more details\n• Try testing the connection first\n• Contact support if issue persists',
                    severity: 'error'
                };
            };

            // Fetch with timeout
            const fetchWithTimeout = async (url, options, timeout = 30000) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    return response;
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        throw new Error('Request timeout - Google Sheets took too long to respond (>30s)');
                    }
                    throw error;
                }
            };

            // Check if error is retriable (only network errors and 5xx)
            const isRetriable = (error, response) => {
                // Network errors (no response) - should retry
                if (!response) return true;

                // Only retry server errors (5xx)
                // Don't retry client errors (4xx) - they won't fix themselves
                return response.status >= 500;
            };

            // Fetch with SMART retry logic - FIXED
            const fetchWithRetry = async (url, options, retries = 3) => {
                let lastResponse = null;

                for (let i = 0; i < retries; i++) {
                    try {
                        addLog('info', `Attempt ${i + 1}/${retries} to reach Google Sheets...`);
                        const response = await fetchWithTimeout(url, options);
                        lastResponse = response;
                        return response;
                    } catch (error) {
                        // Check if we should retry this error
                        if (i === retries - 1 || !isRetriable(error, lastResponse)) {
                            // Don't retry 4xx errors or if this is the last attempt
                            if (lastResponse && lastResponse.status >= 400 && lastResponse.status < 500) {
                                addLog('error', `Client error (${lastResponse.status}) - not retrying`, error.message);
                            }
                            throw error;
                        }

                        const waitTime = 1000 * Math.pow(2, i); // 1s, 2s, 4s
                        addLog('warning', `Attempt ${i + 1} failed, retrying in ${waitTime/1000}s...`, error.message);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    }
                }
            };

            // Response validation
            const validateResponse = async (response) => {
                // Check HTTP status first
                if (!response.ok) {
                    const errorText = await response.text();
                    addLog('error', `HTTP Error ${response.status}`, errorText.substring(0, 200));
                    throw new Error(`HTTP ${response.status}: ${errorText.substring(0, 100)}`);
                }

                // Check content type
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    addLog('error', 'Invalid response format (expected JSON)', text.substring(0, 200));
                    throw new Error(`Expected JSON but got: ${contentType}. Response: ${text.substring(0, 100)}`);
                }

                // Parse JSON safely
                try {
                    const data = await response.json();
                    addLog('success', 'Response received and parsed successfully', data);
                    return data;
                } catch (error) {
                    addLog('error', 'JSON parsing failed', error.message);
                    throw new Error('Invalid JSON response from Google Sheets: ' + error.message);
                }
            };

            // Browser compatibility check
            const checkBrowserCompatibility = () => {
                const issues = [];

                if (typeof fetch === 'undefined') {
                    issues.push('fetch API not supported');
                }
                if (typeof localStorage === 'undefined') {
                    issues.push('localStorage not supported');
                }
                if (typeof Promise === 'undefined') {
                    issues.push('Promises not supported');
                }

                return {
                    compatible: issues.length === 0,
                    issues
                };
            };

            // Calculate sync diff
            const calculateSyncDiff = (localItems, remoteItems) => {
                const localMap = new Map(localItems.map(item => [item.id, item]));
                const remoteMap = new Map(remoteItems.map(item => [item.id, item]));

                const onlyLocal = localItems.filter(item => !remoteMap.has(item.id));
                const onlyRemote = remoteItems.filter(item => !localMap.has(item.id));
                const modified = [];

                localItems.forEach(localItem => {
                    const remoteItem = remoteMap.get(localItem.id);
                    if (remoteItem) {
                        if (JSON.stringify(localItem) !== JSON.stringify(remoteItem)) {
                            modified.push({ local: localItem, remote: remoteItem });
                        }
                    }
                });

                return {
                    onlyLocal,
                    onlyRemote,
                    modified,
                    hasConflicts: modified.length > 0 || (onlyLocal.length > 0 && onlyRemote.length > 0)
                };
            };

            // Load sample data on first use
            useEffect(() => {
                const storedItems = localStorage.getItem('inventoryItems');
                if (storedItems) {
                    setItems(JSON.parse(storedItems));
                    setShowSetupGuide(false);
                } else {
                    // Sample data
                    const sampleData = [
                        { id: 1, name: 'Hammer', box: '10', quantity: '1', notes: 'Claw hammer' },
                        { id: 2, name: 'Hammerrite Paint', box: '15', quantity: '2', notes: 'Black metal paint' },
                        { id: 3, name: 'Hand Saw', box: '10', quantity: '1', notes: '20 inch' },
                        { id: 4, name: 'Screwdriver Set', box: '10', quantity: '1', notes: 'Phillips and flathead' },
                        { id: 5, name: 'Drill', box: '5', quantity: '1', notes: 'Cordless 20V' },
                        { id: 6, name: 'Level', box: '12', quantity: '1', notes: '2 foot aluminum' },
                    ];
                    setItems(sampleData);
                }
            }, []);

            // Save items to localStorage
            useEffect(() => {
                if (items.length > 0) {
                    localStorage.setItem('inventoryItems', JSON.stringify(items));
                }
            }, [items]);

            // Filter items based on search
            useEffect(() => {
                if (searchQuery.trim() === '') {
                    setFilteredItems([]);
                } else {
                    const query = searchQuery.toLowerCase();
                    const filtered = items.filter(item =>
                        item.name.toLowerCase().includes(query) ||
                        item.box.toLowerCase().includes(query) ||
                        (item.notes && item.notes.toLowerCase().includes(query))
                    );
                    setFilteredItems(filtered);
                }
            }, [searchQuery, items]);

            // Show message helper
            const showMessage = (text, type = 'success') => {
                setMessage({ text, type });
                setTimeout(() => setMessage({ text: '', type: '' }), 3000);
            };

            // Add or update item
            const handleSaveItem = async () => {
                if (!formData.name || !formData.box) {
                    showMessage('Please fill in item name and box number', 'error');
                    return;
                }

                if (editingItem) {
                    // Update existing
                    setItems(items.map(item =>
                        item.id === editingItem.id ? { ...item, ...formData } : item
                    ));
                    showMessage('Item updated!');
                } else {
                    // Add new
                    const newItem = {
                        id: Date.now(),
                        ...formData
                    };
                    setItems([...items, newItem]);
                    showMessage('Item added!');
                }

                // Auto-sync to Google Sheets if enabled
                if (settings.autoSync && settings.googleSheetsUrl) {
                    setTimeout(() => pushToSheets(), 500);
                }

                // Reset form
                setFormData({ name: '', box: '', quantity: '1', notes: '', photo: null });
                setEditingItem(null);
                setView('search');
            };

            // Delete item
            const handleDeleteItem = (id) => {
                if (confirm('Are you sure you want to delete this item?')) {
                    setItems(items.filter(item => item.id !== id));
                    showMessage('Item deleted');

                    // Auto-sync to Google Sheets if enabled
                    if (settings.autoSync && settings.googleSheetsUrl) {
                        setTimeout(() => pushToSheets(), 500);
                    }
                }
            };

            // Start editing
            const handleEditItem = (item) => {
                setEditingItem(item);
                setFormData({
                    name: item.name,
                    box: item.box,
                    quantity: item.quantity,
                    notes: item.notes || '',
                    photo: item.photo || null
                });
                setView('add');
            };

            // Push local items to Google Sheets - ENHANCED VERSION
            const pushToSheets = async () => {
                if (!settings.googleSheetsUrl) {
                    showMessage('Please configure Google Sheets URL in settings', 'error');
                    return false;
                }

                // Validate URL first
                const urlCheck = validateGoogleSheetsUrl(settings.googleSheetsUrl);
                if (!urlCheck.valid) {
                    showMessage(urlCheck.error, 'error');
                    dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'error' });
                    return false;
                }

                setIsLoading(true);
                dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'unknown' });
                let response = null;

                try {
                    addLog('info', '📤 Starting PUSH to Google Sheets...');
                    addLog('info', `Items to sync: ${items.length}`);

                    response = await fetchWithRetry(settings.googleSheetsUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'updateAll',
                            items: items
                        })
                    });

                    addLog('info', `Response status: ${response.status}`);

                    const data = await validateResponse(response);

                    if (data.success) {
                        addLog('success', '✅ Push successful!', data);
                        dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'connected' });
                        dispatchSync({
                            type: 'SET_LAST_SYNC',
                            payload: { time: new Date().toLocaleString(), status: 'success' }
                        });

                        // Add to sync history
                        dispatchSync({
                            type: 'ADD_HISTORY',
                            payload: {
                                timestamp: new Date().toISOString(),
                                direction: 'push',
                                status: 'success',
                                itemCount: items.length
                            }
                        });

                        return true;
                    } else {
                        throw new Error(data.error || 'Unknown error from Google Sheets');
                    }
                } catch (error) {
                    const errorInfo = detectErrorType(error, response);
                    addLog('error', errorInfo.title, errorInfo.message);

                    dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'error' });
                    dispatchSync({
                        type: 'SET_LAST_SYNC',
                        payload: { time: new Date().toLocaleString(), status: 'failed' }
                    });

                    // Add to sync history
                    dispatchSync({
                        type: 'ADD_HISTORY',
                        payload: {
                            timestamp: new Date().toISOString(),
                            direction: 'push',
                            status: 'failed',
                            error: errorInfo.message
                        }
                    });

                    showMessage(
                        `${errorInfo.title}\n${errorInfo.message}\n\n💡 ${errorInfo.help}`,
                        'error'
                    );
                    return false;
                } finally {
                    setIsLoading(false);
                }
            };

            // Pull items from Google Sheets - ENHANCED VERSION
            const pullFromSheets = async (showDiff = false) => {
                if (!settings.googleSheetsUrl) {
                    showMessage('Please configure Google Sheets URL in settings', 'error');
                    return false;
                }

                // Validate URL first
                const urlCheck = validateGoogleSheetsUrl(settings.googleSheetsUrl);
                if (!urlCheck.valid) {
                    showMessage(urlCheck.error, 'error');
                    dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'error' });
                    return false;
                }

                setIsLoading(true);
                dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'unknown' });
                let response = null;

                try {
                    addLog('info', '📥 Starting PULL from Google Sheets...');

                    response = await fetchWithRetry(settings.googleSheetsUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'getAll' })
                    });

                    addLog('info', `Response status: ${response.status}`);

                    const data = await validateResponse(response);

                    // CRITICAL: Validate data structure - FIXED
                    if (!data.items || !Array.isArray(data.items)) {
                        throw new Error('Invalid response: items must be an array');
                    }

                    // CRITICAL: Validate each item - FIXED
                    const validItems = data.items.filter(item => {
                        // Item must be an object with required fields
                        return item &&
                               typeof item === 'object' &&
                               item.id != null &&
                               item.name &&
                               item.box != null;
                    });

                    const invalidCount = data.items.length - validItems.length;
                    if (invalidCount > 0) {
                        addLog('warning', `Filtered out ${invalidCount} invalid items (missing id, name, or box)`);
                    }

                    addLog('success', `✅ Pull successful! Received ${validItems.length} valid items`);

                    // Show diff if requested
                    if (showDiff && items.length > 0) {
                        const diff = calculateSyncDiff(items, validItems);
                        if (diff.hasConflicts) {
                            dispatchSync({
                                type: 'SET_SYNC_DIFF',
                                payload: { show: true, data: diff }
                            });
                            setIsLoading(false);
                            return false; // Don't apply yet, let user review
                        }
                    }

                    setItems(validItems);
                    dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'connected' });
                    dispatchSync({
                        type: 'SET_LAST_SYNC',
                        payload: { time: new Date().toLocaleString(), status: 'success' }
                    });

                    // Add to sync history
                    dispatchSync({
                        type: 'ADD_HISTORY',
                        payload: {
                            timestamp: new Date().toISOString(),
                            direction: 'pull',
                            status: 'success',
                            itemCount: validItems.length
                        }
                    });

                    return true;
                } catch (error) {
                    const errorInfo = detectErrorType(error, response);
                    addLog('error', errorInfo.title, errorInfo.message);

                    dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'error' });
                    dispatchSync({
                        type: 'SET_LAST_SYNC',
                        payload: { time: new Date().toLocaleString(), status: 'failed' }
                    });

                    // Add to sync history
                    dispatchSync({
                        type: 'ADD_HISTORY',
                        payload: {
                            timestamp: new Date().toISOString(),
                            direction: 'pull',
                            status: 'failed',
                            error: errorInfo.message
                        }
                    });

                    showMessage(
                        `${errorInfo.title}\n${errorInfo.message}\n\n💡 ${errorInfo.help}`,
                        'error'
                    );
                    return false;
                } finally {
                    setIsLoading(false);
                }
            };

            // Two-way sync with Google Sheets - ENHANCED with REQUEST DEDUPLICATION
            const syncWithSheets = async (direction = 'both') => {
                // CRITICAL: Prevent concurrent sync operations - FIXED
                if (syncInProgress.current) {
                    showMessage('⚠️ Sync already in progress. Please wait...', 'warning');
                    addLog('warning', 'Sync request ignored - operation already in progress');
                    return;
                }

                if (!settings.googleSheetsUrl) {
                    showMessage('Please configure Google Sheets URL in settings', 'error');
                    return;
                }

                syncInProgress.current = true;
                addLog('info', `Starting ${direction.toUpperCase()} sync...`);
                setIsLoading(true);

                try {
                    if (direction === 'push' || direction === 'both') {
                        const pushSuccess = await pushToSheets();
                        if (!pushSuccess) {
                            setIsLoading(false);
                            return; // Stop if push fails
                        }

                        if (direction === 'push') {
                            showMessage('✅ Pushed to Google Sheets!');
                            setIsLoading(false);
                            return;
                        }

                        // For 'both' mode, add delay between push and pull to ensure data is saved
                        if (direction === 'both') {
                            addLog('info', 'Waiting 1 second before pulling to ensure data is saved...');
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }

                    if (direction === 'pull' || direction === 'both') {
                        const pullSuccess = await pullFromSheets();
                        if (pullSuccess) {
                            showMessage(direction === 'both' ? '✅ Two-way sync complete!' : '✅ Pulled from Google Sheets!');
                        }
                    }
                } catch (error) {
                    const errorInfo = detectErrorType(error, null);
                    addLog('error', `Sync failed: ${errorInfo.message}`);
                    showMessage(`Sync failed: ${error.message}`, 'error');
                } finally {
                    // CRITICAL: Always release lock - FIXED
                    setIsLoading(false);
                    syncInProgress.current = false;
                }
            };

            // Test Connection - NEW FEATURE
            const testConnection = async () => {
                const steps = [
                    { name: '1. Validating URL format', status: 'pending', icon: '🔍' },
                    { name: '2. Connecting to Google', status: 'pending', icon: '🌐' },
                    { name: '3. Testing read access', status: 'pending', icon: '📖' },
                    { name: '4. Verifying response format', status: 'pending', icon: '✓' }
                ];

                dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: true } });
                setIsLoading(true);
                addLog('info', '🧪 Starting connection test...');

                try {
                    // Step 1: Validate URL
                    const urlCheck = validateGoogleSheetsUrl(settings.googleSheetsUrl);
                    if (!urlCheck.valid) {
                        steps[0].status = 'failed';
                        steps[0].error = urlCheck.error;
                        dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: false, overallStatus: 'failed' } });
                        addLog('error', 'URL validation failed', urlCheck.error);
                        setIsLoading(false);
                        return;
                    }
                    steps[0].status = 'success';
                    dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: true } });
                    await new Promise(resolve => setTimeout(resolve, 500)); // Visual delay

                    // Step 2: Test connection
                    addLog('info', 'Testing connection...');
                    const response = await fetchWithTimeout(settings.googleSheetsUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'getAll' })
                    }, 10000);

                    if (response.ok) {
                        steps[1].status = 'success';
                        dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: true } });
                    } else {
                        steps[1].status = 'failed';
                        steps[1].error = `HTTP ${response.status}`;
                        dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: false, overallStatus: 'failed' } });
                        addLog('error', `Connection failed: HTTP ${response.status}`);
                        setIsLoading(false);
                        return;
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Step 3: Test read
                    addLog('info', 'Testing read access...');
                    const data = await validateResponse(response);
                    if (data.success !== undefined || data.items !== undefined) {
                        steps[2].status = 'success';
                        dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: true } });
                    } else {
                        steps[2].status = 'failed';
                        steps[2].error = 'Unexpected response format';
                        dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: false, overallStatus: 'failed' } });
                        addLog('error', 'Read test failed: unexpected format');
                        setIsLoading(false);
                        return;
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Step 4: Verify format
                    if (data.items && Array.isArray(data.items)) {
                        steps[3].status = 'success';
                        steps[3].note = `Found ${data.items.length} items`;
                        dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: false, overallStatus: 'success' } });
                        addLog('success', '✅ All connection tests passed!');
                        dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'connected' });
                        showMessage('✅ Connection test passed! Your setup is working correctly.', 'success');
                    } else {
                        steps[3].status = 'success';
                        steps[3].note = 'Empty spreadsheet (this is OK)';
                        dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: false, overallStatus: 'success' } });
                        addLog('success', '✅ Connection test passed (empty sheet)');
                        dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'connected' });
                        showMessage('✅ Connection test passed!', 'success');
                    }

                } catch (error) {
                    const errorInfo = detectErrorType(error, null);
                    const failedStepIndex = steps.findIndex(s => s.status === 'pending');
                    if (failedStepIndex !== -1) {
                        steps[failedStepIndex].status = 'failed';
                        steps[failedStepIndex].error = errorInfo.message;
                    }
                    dispatchSync({ type: 'SET_TEST_RESULTS', payload: { steps, inProgress: false, overallStatus: 'failed', errorHelp: errorInfo.help } });
                    addLog('error', 'Connection test failed', errorInfo.message);
                    dispatchSync({ type: 'SET_CONNECTION_STATUS', payload: 'error' });
                    showMessage(`❌ Connection test failed: ${errorInfo.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            // AI Voice Entry
            const startVoiceRecording = () => {
                if (!settings.aiEnabled) {
                    showMessage('Please enable AI features in settings', 'error');
                    return;
                }

                if ('webkitSpeechRecognition' in window) {
                    const recognition = new webkitSpeechRecognition();
                    recognition.continuous = false;
                    recognition.interimResults = false;

                    recognition.onstart = () => {
                        setIsRecording(true);
                        setTranscript('Listening...');
                    };

                    recognition.onresult = async (event) => {
                        const spokenText = event.results[0][0].transcript;
                        setTranscript(spokenText);
                        // Process the spoken text...
                    };
                }
            }
        }
    </script>
</body>
</html>
